<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2016-08-28T09:27:04.777Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>电池电量检测</title>
    <link href="http://yoursite.com/2016/09/06/SmartSeat/%E7%94%B5%E6%B1%A0%E7%94%B5%E9%87%8F%E6%A3%80%E6%B5%8B/"/>
    <id>http://yoursite.com/2016/09/06/SmartSeat/电池电量检测/</id>
    <published>2016-09-06T15:17:32.830Z</published>
    <updated>2016-08-28T09:27:04.777Z</updated>
    
    <content type="html">&lt;p&gt;电子设计大赛里设计了一个智能健康坐垫。该坐垫使用锂电池供电，所以必须用到电池电量检测，防止电池过放。&lt;/p&gt;
&lt;p&gt;我使用检测电池电压的方法推测电量，不能准确知道电池电量，不过可以设置一个阈值，防止电池过放。&lt;/p&gt;
&lt;p&gt;注意：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;分压电阻的值不能太大，1M以内，减少ADC内部的影响。&lt;/li&gt;
&lt;li&gt;不能大于单片机的最大检测电压。&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;电子设计大赛里设计了一个智能健康坐垫。该坐垫使用锂电池供电，所以必须用到电池电量检测，防止电池过放。&lt;/p&gt;
&lt;p&gt;我使用检测电池电压的方法推测电量，不能准确知道电池电量，不过可以设置一个阈值，防止电池过放。&lt;/p&gt;
&lt;p&gt;注意：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;分压电阻的值不能
    
    </summary>
    
    
      <category term="电量检测" scheme="http://yoursite.com/tags/%E7%94%B5%E9%87%8F%E6%A3%80%E6%B5%8B/"/>
    
  </entry>
  
  <entry>
    <title>uCOSIII应用之定时器应用</title>
    <link href="http://yoursite.com/2016/09/06/SmartSeat/uCOSIII%E5%BA%94%E7%94%A8%E4%B9%8B%E5%AE%9A%E6%97%B6%E5%99%A8%E5%BA%94%E7%94%A8/"/>
    <id>http://yoursite.com/2016/09/06/SmartSeat/uCOSIII应用之定时器应用/</id>
    <published>2016-09-06T15:17:32.830Z</published>
    <updated>2016-08-29T09:21:19.688Z</updated>
    
    <content type="html">&lt;p&gt;uCOSIII系统的定时器可以实现定时（精度不高）。使用方法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;创建定时器变量和声明回调函数&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;OS_TMR 	tmr_active;		//激活定时器&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;void tmr_active_callback(void *p_tmr, void *p_arg); 	//激活定时器回调函数&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;创建定时器&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;	//创建应变片激活定时器&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;OSTmrCreate((OS_TMR		*)&amp;amp;tmr_active,		//激活定时器&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			(CPU_CHAR	*)&quot;tmr active&quot;,		//定时器名字&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			(OS_TICK	 )0,			//0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			(OS_TICK	 )100,          //100*10=1000ms&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			(OS_OPT		 )OS_OPT_TMR_PERIODIC, //周期模式&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			(OS_TMR_CALLBACK_PTR)tmr_active_callback,//激活定时器回调函数&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			(void	    *)0,			//参数为0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			(OS_ERR	    *)&amp;amp;err);		//返回的错误码&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;编写回调函数&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight stylus&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//激活定时器的回调函数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;void tmr_active_callback(void *p_tmr, void *p_arg)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ......&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;启动、关闭定时器&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;(1)OSTmrStart(&amp;amp;tmr_active, &amp;amp;err); //启动定时器&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(2)OSTmrStop (&amp;amp;tmr_negative,OS_OPT_TMR_NONE,0,&amp;amp;err); //关闭定时器&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;uCOSIII系统的定时器可以实现定时（精度不高）。使用方法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;创建定时器变量和声明回调函数&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span
    
    </summary>
    
    
      <category term="uCOSIII,定时器" scheme="http://yoursite.com/tags/uCOSIII-%E5%AE%9A%E6%97%B6%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>uCOSIII应用之信号量应用</title>
    <link href="http://yoursite.com/2016/09/06/SmartSeat/uCOSIII%E5%BA%94%E7%94%A8%E4%B9%8B%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%BA%94%E7%94%A8/"/>
    <id>http://yoursite.com/2016/09/06/SmartSeat/uCOSIII应用之信号量应用/</id>
    <published>2016-09-06T15:17:32.814Z</published>
    <updated>2016-10-19T16:17:29.732Z</updated>
    
    <content type="html">&lt;p&gt;uCOSIII可以使用信号量，使用方法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;创建信号量变量&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;OS_SEM ActiveSem;		//激活信号量&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;创建信号量（创建前必须进入临界区）&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;OSSemCreate ((OS_SEM*)	&amp;amp;ActiveSem,				//创建应变片激活状态信号量&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			   (CPU_CHAR*) &quot;ActiveSem&quot;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			   (OS_SEM_CTR)0,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			   (OS_ERR*)	&amp;amp;err);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;相关指令&lt;br&gt;&lt;img src=&quot;/images/SmartSeat/uCOSIII信号量命令.jpg&quot; alt=&quot;&quot;&gt;&lt;/li&gt;
&lt;/ol&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;uCOSIII可以使用信号量，使用方法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;创建信号量变量&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/s
    
    </summary>
    
    
      <category term="uCOSIII,信号量" scheme="http://yoursite.com/tags/uCOSIII-%E4%BF%A1%E5%8F%B7%E9%87%8F/"/>
    
  </entry>
  
  <entry>
    <title>uCOSIII应用</title>
    <link href="http://yoursite.com/2016/09/06/SmartSeat/uCOSIII%E5%BA%94%E7%94%A8/"/>
    <id>http://yoursite.com/2016/09/06/SmartSeat/uCOSIII应用/</id>
    <published>2016-09-06T15:17:32.814Z</published>
    <updated>2016-08-29T09:28:58.450Z</updated>
    
    <content type="html">&lt;p&gt;智能坐垫的设计用到了uCOSIII实时操作系统。uCOSIII系统使用说明：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;创建任务块&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//任务优先级&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#define START_TASK_PRIO		3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//任务堆栈大小	&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#define START_STK_SIZE 		512&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//任务控制块&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;OS_TCB StartTaskTCB;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//任务堆栈	&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;CPU_STK START_TASK_STK[START_STK_SIZE];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//任务函数&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;void start_task(void *p_arg);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;在main函数中初始化系统，创建START任务&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;OSInit(&amp;amp;err);		//初始化UCOSIII&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;OS_CRITICAL_ENTER();//进入临界区&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//创建开始任务&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;OSTaskCreate((OS_TCB 	* )&amp;amp;StartTaskTCB,		//任务控制块&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			 (CPU_CHAR	* )&quot;start task&quot;, 		//任务名字&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			 (OS_TASK_PTR )start_task, 			//任务函数&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			 (void		* )0,					//传递给任务函数的参数&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			 (OS_PRIO	  )START_TASK_PRIO,     //任务优先级&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			 (CPU_STK   * )&amp;amp;START_TASK_STK[0],	//任务堆栈基地址&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			 (CPU_STK_SIZE)START_STK_SIZE/10,	//任务堆栈深度限位&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			 (CPU_STK_SIZE)START_STK_SIZE,		//任务堆栈大小&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			 (OS_MSG_QTY  )0,					//任务内部消息队列能够接收的最大消息数目,为0时禁止接收消息&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			 (OS_TICK	  )0,					//当使能时间片轮转时的时间片长度，为0时为默认长度，&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			 (void   	* )0,					//用户补充的存储区&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			 (OS_OPT      )OS_OPT_TASK_STK_CHK|OS_OPT_TASK_STK_CLR, //任务选项&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			 (OS_ERR 	* )&amp;amp;err);				//存放该函数错误时的返回值&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;OS_CRITICAL_EXIT();	//退出临界区	 &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;OSStart(&amp;amp;err);  //开启UCOSIII&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;在START任务中进行系统设置&lt;br&gt;(1)统计任务、中断关闭时间测量、时间片轮转功能使能&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;#if OS_CFG_STAT_TASK_EN &amp;gt; 0u&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   OSStatTaskCPUUsageInit(&amp;amp;err);  	//统计任务                &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#endif&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#ifdef CPU_CFG_INT_DIS_MEAS_EN		//如果使能了测量中断关闭时间&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    CPU_IntDisMeasMaxCurReset();	&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#endif&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#if	OS_CFG_SCHED_ROUND_ROBIN_EN  //当使用时间片轮转的时候&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	 //使能时间片轮转调度功能,时间片长度为1个系统时钟节拍，既1*5=5ms&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	OSSchedRoundRobinCfg(DEF_ENABLED,1,&amp;amp;err);  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#endif&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;(2)创建定时器(如果有使用)&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;	//创建应变片激活定时器&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;OSTmrCreate((OS_TMR		*)&amp;amp;tmr_active,		//激活定时器&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			(CPU_CHAR	*)&quot;tmr active&quot;,		//定时器名字&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			(OS_TICK	 )0,			//0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			(OS_TICK	 )100,          //100*10=1000ms&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			(OS_OPT		 )OS_OPT_TMR_PERIODIC, //周期模式&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			(OS_TMR_CALLBACK_PTR)tmr_active_callback,//激活定时器回调函数&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			(void	    *)0,			//参数为0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			(OS_ERR	    *)&amp;amp;err);		//返回的错误码&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;(3)创建信号量和各任务(如果有使用)&lt;br&gt;&lt;strong&gt;注意：创建之前必须进入临界区&lt;/strong&gt;&lt;code&gt;OS_CRITICAL_ENTER();    //进入临界区&lt;/code&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;OSSemCreate ((OS_SEM*)	&amp;amp;ActiveSem,				//创建应变片激活状态信号量&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			   (CPU_CHAR*) &quot;ActiveSem&quot;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			   (OS_SEM_CTR)0,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			   (OS_ERR*)	&amp;amp;err);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;hr&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//创建系统核心任务&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;OSTaskCreate((OS_TCB 	* )&amp;amp;CORETaskTCB,		&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			 (CPU_CHAR	* )&quot;core task&quot;, 		&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			 (OS_TASK_PTR )core_task, 			&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			 (void		* )0,					&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			 (OS_PRIO	  )CORE_TASK_PRIO,     &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			 (CPU_STK   * )&amp;amp;CORE_TASK_STK[0],	&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			 (CPU_STK_SIZE)CORE_STK_SIZE/10,	&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			 (CPU_STK_SIZE)CORE_STK_SIZE,		&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			 (OS_MSG_QTY  )0,					&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			 (OS_TICK	  )0,					&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			 (void   	* )0,					&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			 (OS_OPT      )OS_OPT_TASK_STK_CHK|OS_OPT_TASK_STK_CLR,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			 (OS_ERR 	* )&amp;amp;err);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;(4)挂起任务和退出临界区&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;OS_TaskSuspend((OS_TCB*)&amp;amp;StartTaskTCB,&amp;amp;err);		//挂起开始任务			 &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;OS_CRITICAL_EXIT();	//退出临界区&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;各任务函数编写&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;每一个任务必须是死循环，在死循环中加入一个可以挂起任务的函数，以实现任务调度&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;void active_task(void *p_arg)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	OS_ERR err;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	p_arg = p_arg;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	while(1)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	......&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		OSTimeDlyHMSM(0,0,1,0,OS_OPT_TIME_HMSM_STRICT,&amp;amp;err); //延时1s&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;hr&gt;
&lt;h2 id=&quot;注意&quot;&gt;&lt;a href=&quot;#注意&quot; class=&quot;headerlink&quot; title=&quot;注意&quot;&gt;&lt;/a&gt;注意&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;最后一个参数都是错误反馈&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;智能坐垫的设计用到了uCOSIII实时操作系统。uCOSIII系统使用说明：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;创建任务块&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span c
    
    </summary>
    
    
      <category term="uCOSIII,应用" scheme="http://yoursite.com/tags/uCOSIII-%E5%BA%94%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2016/09/06/SmartSeat/LM358%E5%BA%94%E7%94%A8/"/>
    <id>http://yoursite.com/2016/09/06/SmartSeat/LM358应用/</id>
    <published>2016-09-06T15:17:32.814Z</published>
    <updated>2016-08-28T12:11:41.085Z</updated>
    
    <content type="html"></content>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>画板总结（电子设计竞赛画板总结）</title>
    <link href="http://yoursite.com/2016/09/06/Altium%20Designer/%E7%94%BB%E6%9D%BF%E6%80%BB%E7%BB%93(%E4%BA%8C)/"/>
    <id>http://yoursite.com/2016/09/06/Altium Designer/画板总结(二)/</id>
    <published>2016-09-06T15:17:32.736Z</published>
    <updated>2016-08-02T15:03:50.100Z</updated>
    
    <content type="html">&lt;p&gt;在2016广东大学生电子设计竞赛中，因为比赛需要画了一块电源板。虽然已多次检查，但还是出现了一个严重的错误，USB接口的电源和地定义反了（由于使用的是之前项目使用过的MicroUSB接口封装，并没有仔细检查）。&lt;/p&gt;
&lt;p&gt;而且有个别焊盘也偏小，焊接的时候不方便&lt;/p&gt;
&lt;p&gt;画板后的检查过程：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;对照官方PDF文档，检查器件封装是否有错。&lt;/li&gt;
&lt;li&gt;检查焊盘大小，最好对照实物，有现成的库的尽量用现成的库，最好不要自己画。如果没有现成库，尽量把焊盘画得大些，像贴片电感、电容画得比实物尺寸长1mm都可以。&lt;/li&gt;
&lt;li&gt;最后检查走线，线宽、线距是否足够，接地是否用敷铜等。这主要是依照经验值及芯片文档说明。&lt;/li&gt;
&lt;/ol&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;在2016广东大学生电子设计竞赛中，因为比赛需要画了一块电源板。虽然已多次检查，但还是出现了一个严重的错误，USB接口的电源和地定义反了（由于使用的是之前项目使用过的MicroUSB接口封装，并没有仔细检查）。&lt;/p&gt;
&lt;p&gt;而且有个别焊盘也偏小，焊接的时候不方便&lt;/p&gt;

    
    </summary>
    
    
      <category term="PCB板" scheme="http://yoursite.com/tags/PCB%E6%9D%BF/"/>
    
  </entry>
  
  <entry>
    <title>Altium Designer设置敷铜安全距离</title>
    <link href="http://yoursite.com/2016/09/06/Altium%20Designer/Altium%20Designer%E8%AE%BE%E7%BD%AE%E6%95%B7%E9%93%9C%E5%AE%89%E5%85%A8%E8%B7%9D%E7%A6%BB/"/>
    <id>http://yoursite.com/2016/09/06/Altium Designer/Altium Designer设置敷铜安全距离/</id>
    <published>2016-09-06T15:17:32.736Z</published>
    <updated>2016-07-13T12:24:01.939Z</updated>
    
    <content type="html">&lt;p&gt;设计-规则-electrical-clearance-选中右键-新规则-左键点中新规则-右边出现设置框-在上面的“where the first object matches”框下面的高级旁边，点“询问助手”-在右边“全部询问”处输入“Inpolygon” ，并修改最小间隔距离。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;设计-规则-electrical-clearance-选中右键-新规则-左键点中新规则-右边出现设置框-在上面的“where the first object matches”框下面的高级旁边，点“询问助手”-在右边“全部询问”处输入“Inpolygon” ，并修改最小间隔
    
    </summary>
    
    
      <category term="Altium Designer,敷铜安全距离" scheme="http://yoursite.com/tags/Altium-Designer-%E6%95%B7%E9%93%9C%E5%AE%89%E5%85%A8%E8%B7%9D%E7%A6%BB/"/>
    
  </entry>
  
  <entry>
    <title>PCB板绘制经验总结</title>
    <link href="http://yoursite.com/2016/09/06/Altium%20Designer/PCB%E6%9D%BF%E7%BB%98%E5%88%B6%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2016/09/06/Altium Designer/PCB板绘制经验总结/</id>
    <published>2016-09-06T15:17:32.736Z</published>
    <updated>2016-08-01T02:36:24.732Z</updated>
    
    <content type="html">&lt;p&gt;此文记录PCB板绘制过程中总结的经验和规则&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;过孔直径一般小于0.5mm，焊盘直径比过孔直径一般大0.3mm。&lt;/li&gt;
&lt;li&gt;线路的安全距离，电源线可以适当加大，信号线可以稍小。&lt;/li&gt;
&lt;li&gt;绘制贴片元件封装时，焊盘大小要比手册上的尺寸稍大，芯片封装的焊盘可加长0.5mm，电感、电容之类的器件封装可加长1mm，便于手工焊接。&lt;/li&gt;
&lt;/ol&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;此文记录PCB板绘制过程中总结的经验和规则&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;过孔直径一般小于0.5mm，焊盘直径比过孔直径一般大0.3mm。&lt;/li&gt;
&lt;li&gt;线路的安全距离，电源线可以适当加大，信号线可以稍小。&lt;/li&gt;
&lt;li&gt;绘制贴片元件封装时，焊盘大小要比手册上的尺寸稍大
    
    </summary>
    
    
      <category term="PCB板 经验总结" scheme="http://yoursite.com/tags/PCB%E6%9D%BF-%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu命令归纳</title>
    <link href="http://yoursite.com/2016/05/06/Ubuntu%E5%91%BD%E4%BB%A4%E5%BD%92%E7%BA%B3/"/>
    <id>http://yoursite.com/2016/05/06/Ubuntu命令归纳/</id>
    <published>2016-05-06T14:32:11.326Z</published>
    <updated>2016-05-06T16:10:45.919Z</updated>
    
    <content type="html">&lt;p&gt;近段时间在做CONTIKI系统应用开发，需要用到Ubuntu，所以把Ubuntu需要用到的命令记录下来，以便以后查询使用。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;解压命令&lt;/p&gt;
&lt;p&gt;unzip &lt;packagename\&gt;&lt;/packagename\&gt;&lt;/p&gt;
&lt;p&gt;tar -zxf &lt;packagename\&gt;&lt;/packagename\&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;近段时间在做CONTIKI系统应用开发，需要用到Ubuntu，所以把Ubuntu需要用到的命令记录下来，以便以后查询使用。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;解压命令&lt;/p&gt;
&lt;p&gt;unzip &lt;packagename\&gt;&lt;/packagename\&gt;&lt;/p&gt;
&lt;p&gt;tar 
    
    </summary>
    
    
      <category term="Ubuntu,命令" scheme="http://yoursite.com/tags/Ubuntu-%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu分区大小调整</title>
    <link href="http://yoursite.com/2016/05/06/Ubuntu%E5%88%86%E5%8C%BA%E5%A4%A7%E5%B0%8F%E8%B0%83%E6%95%B4/"/>
    <id>http://yoursite.com/2016/05/06/Ubuntu分区大小调整/</id>
    <published>2016-05-06T14:32:11.324Z</published>
    <updated>2016-05-06T09:36:32.605Z</updated>
    
    <content type="html">&lt;p&gt;如果要调整系统分区，就要用到光盘版的GParted-LiveCD。&lt;/p&gt;
&lt;p&gt;可能存在的问题：&lt;br&gt;可能会发生swap分区丢失的情况，可在终端中用“free -m”命令查看swap分区是否激活(是否显示容量)，如果未激活，可用“sudo mkswap /dev/sdaX”命令(X为swap分区的编号)进行激活，并将激活所得的UUID码替换掉“/etc/fstab”文件(需要管理员权限)中原来 swap分区的UUID编码，重启后即可自动激活挂载。&lt;/p&gt;
&lt;p&gt;警告：对swap分区的激活操作及对fstab文件的修改应谨慎，必需仔细核对修改的值。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.linuxidc.com/Linux/2013-06/85747.htm&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;参考网站1&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://www.linuxidc.com/Linux/2015-03/115027.htm&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;参看网站2&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;如果要调整系统分区，就要用到光盘版的GParted-LiveCD。&lt;/p&gt;
&lt;p&gt;可能存在的问题：&lt;br&gt;可能会发生swap分区丢失的情况，可在终端中用“free -m”命令查看swap分区是否激活(是否显示容量)，如果未激活，可用“sudo mkswap /dev/sda
    
    </summary>
    
    
      <category term="Ubuntu,分区" scheme="http://yoursite.com/tags/Ubuntu-%E5%88%86%E5%8C%BA/"/>
    
  </entry>
  
  <entry>
    <title>Source Insight显示中文</title>
    <link href="http://yoursite.com/2016/05/06/Source%20Insight%E6%98%BE%E7%A4%BA%E4%B8%AD%E6%96%87/"/>
    <id>http://yoursite.com/2016/05/06/Source Insight显示中文/</id>
    <published>2016-05-06T14:32:11.322Z</published>
    <updated>2016-04-10T03:53:17.454Z</updated>
    
    <content type="html">&lt;p&gt;source insight 中文注释为乱码解决&lt;/p&gt;
&lt;p&gt;source insight 阅读VC++源码，注释为乱码解决方案&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;options-&amp;gt;preferences-&amp;gt;Syntax Formatting-&amp;gt;Styles；&lt;/li&gt;
&lt;li&gt;在Style Name 选择 Comment，再对其Font Name 选择Pick，然后再选择“新宋体”，编码选择GB2312。&lt;/li&gt;
&lt;/ol&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;source insight 中文注释为乱码解决&lt;/p&gt;
&lt;p&gt;source insight 阅读VC++源码，注释为乱码解决方案&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;options-&amp;gt;preferences-&amp;gt;Syntax Formatting-&amp;gt;Styles；&lt;
    
    </summary>
    
    
      <category term="Source Insight 中文" scheme="http://yoursite.com/tags/Source-Insight-%E4%B8%AD%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>GIT for Linux安装</title>
    <link href="http://yoursite.com/2016/05/06/GIT%20for%20Linux%E5%AE%89%E8%A3%85/"/>
    <id>http://yoursite.com/2016/05/06/GIT for Linux安装/</id>
    <published>2016-05-06T14:32:11.320Z</published>
    <updated>2016-05-06T09:35:50.081Z</updated>
    
    <content type="html">&lt;p&gt;因为最近在做CONTIKI系统应用的开发，要用到GIT。在Ubuntu上安装GIT时遇到一个问题，编译的时候报错&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Writing perl.mak for Git
make[2]: *** [perl.mak] Error 1
make[1]: *** [instlibdir] Error 2
make: *** [git-add--interactive] Error 2
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;一开始以为是缺少环境，几次检查后确定没有问题。最后发现是系统时间设置错误，系统的时间早于版本的时间，在时间正确设置后，问题解决。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;因为最近在做CONTIKI系统应用的开发，要用到GIT。在Ubuntu上安装GIT时遇到一个问题，编译的时候报错&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Writing perl.mak for Git
make[2]: *** [perl.mak] Error 1
make[1]:
    
    </summary>
    
    
      <category term="GIT for Linux" scheme="http://yoursite.com/tags/GIT-for-Linux/"/>
    
  </entry>
  
  <entry>
    <title>SSD1306的SPI协议</title>
    <link href="http://yoursite.com/2016/05/06/DEV/SSD1306%E7%9A%84SPI%E5%8D%8F%E8%AE%AE/"/>
    <id>http://yoursite.com/2016/05/06/DEV/SSD1306的SPI协议/</id>
    <published>2016-05-06T14:32:11.112Z</published>
    <updated>2016-10-19T15:41:29.149Z</updated>
    
    <content type="html">&lt;p&gt;近段时间调试小尺寸的OLED显示屏，虽然是SPI协议，接口上却写着SCL和SDA。所以要注意的是这种集成模块的OLED并不是使用IIC协议，而是SPI协议，而且并不用管CS，接低电平即可。&lt;br&gt;&lt;img src=&quot;/images/DEV/OLED.jpg&quot; alt=&quot;OLED外观&quot; title=&quot;OLED.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;SSD1306的SPI协议时序图，因为这个OLED默认就把CS拉低了，所以每次传输可以不用去管CS，但没CS这几个IO就被独占了。从图上可以看到数据是在SCLK上升沿时被传入，高位在前。DC用于表示写入的是数据还是指令，DC为低时是指令写入，DC为高时是数据写入。&lt;br&gt;128*64的OLED在SSD1306的控制下，被分成8个页，每个页有8行128列，每个列对应一个字节。&lt;br&gt;&lt;img src=&quot;/images/DEV/SSD1306SPI%E5%9B%9B%E7%BA%BF.png&quot; alt=&quot;SSD1306SPI四线&quot; title=&quot;SSD1306SPI四线.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.eeboard.com/bbs/forum.php?mod=viewthread&amp;amp;tid=22116&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;参考网站&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;近段时间调试小尺寸的OLED显示屏，虽然是SPI协议，接口上却写着SCL和SDA。所以要注意的是这种集成模块的OLED并不是使用IIC协议，而是SPI协议，而且并不用管CS，接低电平即可。&lt;br&gt;&lt;img src=&quot;/images/DEV/OLED.jpg&quot; alt=&quot;OL
    
    </summary>
    
    
      <category term="SSD1306,SPI" scheme="http://yoursite.com/tags/SSD1306-SPI/"/>
    
  </entry>
  
  <entry>
    <title>OLED(SSD1306驱动芯片)的IIC协议</title>
    <link href="http://yoursite.com/2016/05/06/DEV/IIC%E5%8D%8F%E8%AE%AE(OLED_SSD1306)/"/>
    <id>http://yoursite.com/2016/05/06/DEV/IIC协议(OLED_SSD1306)/</id>
    <published>2016-05-06T14:32:11.095Z</published>
    <updated>2016-10-19T15:44:37.975Z</updated>
    
    <content type="html">&lt;p&gt;下面是OLED(SSD1306驱动芯片)IIC协议的摘要中文翻译&lt;br&gt;&lt;img src=&quot;/images/DEV/从设备地址.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;SCL和SDA都要接上拉电阻&lt;/li&gt;
&lt;li&gt;数据传输中SDA只能在SCL为低时转变，在SCL为高时必须保持不变&lt;/li&gt;
&lt;li&gt;RES接口用于设备初始化&lt;/li&gt;
&lt;li&gt;&lt;p&gt;DC接口作为从设备选择位，当R/W为1时是读取模式，R/W为0时是写入模式。 &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;ACK信号在一个SCL的高电平时输出，0为成功，1为失败&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;IIC写入的顺序&lt;br&gt;(1)开始信号&lt;br&gt;(2)从设备地址&lt;br&gt;(3)写入控制字节和数据字节。控制字节为CO+D/C+6个0。&lt;br&gt;如果CO为0，表示没有连续写入。&lt;br&gt;如果D/C为0，表示写入命令；D/C为1，表示写入数据，数据将储存在GDDRAM中，GDDRAM中的数据指针会自动加1&lt;br&gt;(4)每一次写入都会有ACK&lt;br&gt;&lt;img src=&quot;/images/DEV/IIC写入.jpg&quot; alt=&quot;IIC写入过程&quot;&gt;&lt;br&gt;(5)IIC开始信号为SDA由高到底，结束信号为由低到高，SCL都要为高&lt;br&gt;&lt;img src=&quot;/images/DEV/IIC%E9%80%9A%E8%AE%AF%E5%BC%80%E5%A7%8B.jpg&quot; alt=&quot;IIC开始与结束&quot; title=&quot;IIC通讯开始.jpg&quot;&gt;&lt;/li&gt;
&lt;/ol&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;下面是OLED(SSD1306驱动芯片)IIC协议的摘要中文翻译&lt;br&gt;&lt;img src=&quot;/images/DEV/从设备地址.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;SCL和SDA都要接上拉电阻&lt;/li&gt;
&lt;li&gt;数据传输中SDA只能在SCL为低时转变，在SC
    
    </summary>
    
    
      <category term="SSD1306,IIC" scheme="http://yoursite.com/tags/SSD1306-IIC/"/>
    
  </entry>
  
  <entry>
    <title>12864LCD显示屏的串口协议</title>
    <link href="http://yoursite.com/2016/05/06/DEV/12864LCD%E4%B8%B2%E5%8F%A3%E5%8D%8F%E8%AE%AE/"/>
    <id>http://yoursite.com/2016/05/06/DEV/12864LCD串口协议/</id>
    <published>2016-05-06T14:32:11.075Z</published>
    <updated>2016-10-19T15:39:12.829Z</updated>
    
    <content type="html">&lt;p&gt;12864LCD显示屏可以选择使用串口还是并口模式&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/DEV/12864%E7%AB%AF%E5%8F%A3%E5%AE%9A%E4%B9%89.jpg&quot; alt=&quot;12864端口定义&quot; title=&quot;12864端口定义.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;如上图所示,PSB接地时12864采用串口模式。&lt;/p&gt;
&lt;p&gt;所以当使用串口模式时，硬件的连接为：&lt;br&gt;GND,PSB,LED_K接地；VCC,VO,RS(CS),/RST,LED_A接+5V；&lt;br&gt;R/W(SID)接SPI数据口；E(CLK)接SPI时钟口。&lt;/p&gt;
&lt;p&gt;12864LCD显示屏的数据分三个字节传输&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/DEV/12864%E4%B8%B2%E5%8F%A3%E6%97%B6%E5%BA%8F.jpg&quot; alt=&quot;12864LCD串行时序&quot; title=&quot;12864串口时序.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;(1)控制字节，控制数据传输方向和数据类型&lt;br&gt;(2)8位数据的高4位&lt;br&gt;(3)8位数据的低4位&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://bbs.elecfans.com/jishu_407275_1_1.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;参考网站&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;12864LCD显示屏可以选择使用串口还是并口模式&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/DEV/12864%E7%AB%AF%E5%8F%A3%E5%AE%9A%E4%B9%89.jpg&quot; alt=&quot;12864端口定义&quot; title=&quot;12864端口定义.jp
    
    </summary>
    
    
      <category term="12864,串口" scheme="http://yoursite.com/tags/12864-%E4%B8%B2%E5%8F%A3/"/>
    
  </entry>
  
  <entry>
    <title>CONTIKI应用之网络功能应用</title>
    <link href="http://yoursite.com/2016/05/06/CONTIKI/CONTIKI%E5%BA%94%E7%94%A8%E4%B9%8B%E7%BD%91%E7%BB%9C%E5%BA%94%E7%94%A8/"/>
    <id>http://yoursite.com/2016/05/06/CONTIKI/CONTIKI应用之网络应用/</id>
    <published>2016-05-06T14:32:10.945Z</published>
    <updated>2016-04-18T16:06:02.690Z</updated>
    
    <content type="html">&lt;p&gt;学校挑战杯项目是关于物联网的，需要用到CONTIKI系统的网络功能。在开发过程中遇到不少问题，所以把问题记录下来，以便以后总结。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;用contiki-wsn2530dk例程里的第9个“RPL-Collect”时“Sink”节点不调用collect_common_set_send_active()函数就不能接受节点的数据。&lt;br&gt;因为在Contiki2.7中send_active变量初始化为0，需要调用collect_common_set_send_active()给send_active变量赋值为1。而Contiki3.0中send_active变量初始化为1，并不需要再赋值。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;uip_ipaddr_copy(&amp;amp;server_conn-&amp;gt;ripaddr, &amp;amp;clientipaddr);
uip_udp_packet_send(server_conn, &amp;quot;GET&amp;quot;, sizeof(&amp;quot;GET&amp;quot;));
uip_create_unspecified(&amp;amp;server_conn-&amp;gt;ripaddr);&lt;/code&gt;&lt;br&gt;主机给节点发送数据需要用到上面的函数，而用&lt;br&gt;`          uip_udp_packet_sendto(server_conn, buf, strlen(buf),&lt;pre&gt;&lt;code&gt;&amp;amp;clientipaddr, UIP_HTONS(UDP_CLIENT_PORT));`
&lt;/code&gt;&lt;/pre&gt;这个函数却不能把数据发送的节点，原因暂时不明。&lt;/li&gt;
&lt;/ol&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;学校挑战杯项目是关于物联网的，需要用到CONTIKI系统的网络功能。在开发过程中遇到不少问题，所以把问题记录下来，以便以后总结。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;用contiki-wsn2530dk例程里的第9个“RPL-Collect”时“Sink”节点不调用collect_c
    
    </summary>
    
    
      <category term="CONTIKI,网络" scheme="http://yoursite.com/tags/CONTIKI-%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>CONTIKI应用之传感器驱动编写</title>
    <link href="http://yoursite.com/2016/05/06/CONTIKI/CONTIKI%E5%BA%94%E7%94%A8%E4%B9%8B%E4%BC%A0%E6%84%9F%E5%99%A8%E9%A9%B1%E5%8A%A8%E7%BC%96%E5%86%99/"/>
    <id>http://yoursite.com/2016/05/06/CONTIKI/CONTIKI应用之传感器驱动编写/</id>
    <published>2016-05-06T14:32:10.926Z</published>
    <updated>2016-05-06T09:34:14.765Z</updated>
    
    <content type="html">&lt;p&gt;在用CONTIKI系统做开发时，免不了编写各种传感器的驱动。现把开发时遇到的问题和得出的经验记录下来，以便以后总结。&lt;/p&gt;
&lt;p&gt;CONTIKI系统的传感器驱动都封装在sensor这个结构体内&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;struct sensors_sensor {
    char *       type; //传感器名称
    int          (* value)     (int type); //指向读取传感器数据函数的指针
    int          (* configure) (int type, int value); //指向传感器配置函数的指针
    int          (* status)    (int type); //指向读取传感器状态函数的指针
};
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在编写完传感器的驱动程序后，必须通过宏定义声明各个函数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SENSORS_SENSOR(button_1_sensor, BUTTON_SENSOR, value_b1, configure_b1, status_b1);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;并且在”smartrf-sensors.c”的结构体中&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const struct sensors_sensor *sensors[] = {
#if ADC_SENSOR_ON
&amp;amp;adc_sensor,
#endif
#if BUTTON_SENSOR_ON
&amp;amp;button_1_sensor,
#if MODELS_CONF_CC2531_USB_STICK
&amp;amp;button_2_sensor,
#endif
#endif
0
};
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;添加你所编写的驱动的名称。&lt;/p&gt;
&lt;p&gt;系统会在”sensors.c”中，搜索*sensors[]数组中的值&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;for(i = 0; sensors[i] != NULL; ++i) {
    sensors_flags[i] = 0;
    sensors[i]-&amp;gt;configure(SENSORS_HW_INIT, 0);
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;用”sensors_changed”函数标记传感器事件的发生，并传递给用户程序。&lt;/p&gt;
&lt;p&gt;用”sensors_find”函数查找传感器驱动&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sensor =(struct sensors_sensor *) sensors_find(ADC_SENSOR);
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;在用CONTIKI系统做开发时，免不了编写各种传感器的驱动。现把开发时遇到的问题和得出的经验记录下来，以便以后总结。&lt;/p&gt;
&lt;p&gt;CONTIKI系统的传感器驱动都封装在sensor这个结构体内&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;struct sensors_sensor {

    
    </summary>
    
    
      <category term="CONTIKI,传感器驱动" scheme="http://yoursite.com/tags/CONTIKI-%E4%BC%A0%E6%84%9F%E5%99%A8%E9%A9%B1%E5%8A%A8/"/>
    
  </entry>
  
  <entry>
    <title>CONTIKI应用之串口应用</title>
    <link href="http://yoursite.com/2016/05/06/CONTIKI/CONTIKI%E5%BA%94%E7%94%A8%E4%B9%8B%E4%B8%B2%E5%8F%A3%E5%BA%94%E7%94%A8/"/>
    <id>http://yoursite.com/2016/05/06/CONTIKI/CONTIKI应用之串口应用/</id>
    <published>2016-05-06T14:32:10.923Z</published>
    <updated>2016-10-19T15:36:56.827Z</updated>
    
    <content type="html">&lt;p&gt;在CONTIKI开发时经常用到串口，所以把遇到的问题记录下来，以便以后总结。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;CC2530的串口驱动有一个BUG，会导致串口不能接收数据，现已修正。serial-line.c是串口的驱动程序，里面有一个“int”类型的“c”变量用来判断是否收到串口数据，而ringbuf_get()函数是用来轮询串口是否有数据输入的，返回一个“int”类型的数值。“c”变量与ringbuf_get()函数的返回值必须是同类型的，而在原来的程序中两者的类型并不相等，导致数据溢出，不能进入串口数据处理进程。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;/images/CONTIKI/CC2530平台串口BUG_1.jpg&quot; alt=&quot;CC2530平台串口BUG_1&quot;&gt;&lt;br&gt;&lt;img src=&quot;/images/CONTIKI/CC2530平台串口BUG_2.jpg&quot; alt=&quot;CC2530平台串口BUG_2&quot;&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;在CONTIKI开发时经常用到串口，所以把遇到的问题记录下来，以便以后总结。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;CC2530的串口驱动有一个BUG，会导致串口不能接收数据，现已修正。serial-line.c是串口的驱动程序，里面有一个“int”类型的“c”变量用来判断是否收到串口
    
    </summary>
    
    
      <category term="CONTIKI,串口" scheme="http://yoursite.com/tags/CONTIKI-%E4%B8%B2%E5%8F%A3/"/>
    
  </entry>
  
  <entry>
    <title>CONTIKI应用之Ubuntu环境下开发</title>
    <link href="http://yoursite.com/2016/05/06/CONTIKI/CONTIKI%E5%BA%94%E7%94%A8%E4%B9%8BUbuntu%E7%8E%AF%E5%A2%83%E4%B8%8B%E5%BC%80%E5%8F%91/"/>
    <id>http://yoursite.com/2016/05/06/CONTIKI/CONTIKI应用之Ubuntu环境下开发/</id>
    <published>2016-05-06T14:32:10.921Z</published>
    <updated>2016-05-06T09:33:34.065Z</updated>
    
    <content type="html">&lt;p&gt;CONTIKI系统默认是在Ubuntu下使用SDCC开发的，因为SDCC采用的是GCC编译器，与Windows下的IAR或KEIL还是有很大的不同。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使用SDCC必须要写好Makefile文件，这样编译器才能在编译时找到相应的文件。&lt;/li&gt;
&lt;li&gt;因为GCC编译器是使用标准C，所以在IAR上能编译成功不代表在SDCC上也能编译成功。例如我在编译时遇到一个问题，提示“变量初始化的值不能为变量”。这是因为标准C规定变量初始化时一定要为常量，如果要用变量赋值，必须要在函数或宏定义中。&lt;/li&gt;
&lt;li&gt;因为CC2530的栈空间不够，所以CONTIKI系统CC2530平台上的UDP-IPV6例程有重启的问题。所以对于CC2530平台，在没有修改UIP协议栈的情况下，不能作为ROOT节点。解决方法是使用sensinode分支的源代码，该分支的版本是CONTIKI2.6，修改了部分文件的代码减少堆栈开销。&lt;/li&gt;
&lt;/ol&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;CONTIKI系统默认是在Ubuntu下使用SDCC开发的，因为SDCC采用的是GCC编译器，与Windows下的IAR或KEIL还是有很大的不同。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使用SDCC必须要写好Makefile文件，这样编译器才能在编译时找到相应的文件。&lt;/li&gt;
&lt;l
    
    </summary>
    
    
      <category term="CONTIKI,Ubuntu" scheme="http://yoursite.com/tags/CONTIKI-Ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>CONTIKI应用之static和extern的使用</title>
    <link href="http://yoursite.com/2016/05/06/CONTIKI/CONTIKI%E5%BA%94%E7%94%A8%E4%B9%8Bstatic%E5%92%8Cextern/"/>
    <id>http://yoursite.com/2016/05/06/CONTIKI/CONTIKI应用之static和extern/</id>
    <published>2016-05-06T14:32:10.917Z</published>
    <updated>2016-05-06T09:32:53.452Z</updated>
    
    <content type="html">&lt;p&gt;在Contiki进程中如果不用static声明变量，变量的值会在程序切换或退出时丢失。所以在编写Contiki用户程序时，如果需要变量的值一直保持，就必须在声明变量时用static。&lt;/p&gt;
&lt;p&gt;但使用static后，声明的变量或函数只能在该文档中使用。如果你的变量需要在整个工程中使用，就不能用static，而是定义一个全局变量，在使用时再用extern声明。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;在Contiki进程中如果不用static声明变量，变量的值会在程序切换或退出时丢失。所以在编写Contiki用户程序时，如果需要变量的值一直保持，就必须在声明变量时用static。&lt;/p&gt;
&lt;p&gt;但使用static后，声明的变量或函数只能在该文档中使用。如果你的变量需要在
    
    </summary>
    
    
      <category term="CONTIKI,static和extern" scheme="http://yoursite.com/tags/CONTIKI-static%E5%92%8Cextern/"/>
    
  </entry>
  
</feed>
